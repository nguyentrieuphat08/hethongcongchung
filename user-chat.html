<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat AI - T·∫°o H·ª£p ƒë·ªìng</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <style>
        body {
            background-color: #f8f9fa;
        }
        .sidebar {
            background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
            width: 200px;
            z-index: 100;
        }
        .nav-link.active {
            background-color: rgba(255,255,255,0.2);
            border-radius: 8px;
        }
        .nav-link:hover {
            background-color: rgba(255,255,255,0.1);
            border-radius: 8px;
        }
        .main-content {
            margin-left: 200px;
            padding: 20px;
        }
        .chat-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .chat-container {
            height: 250px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            background-color: #f8f9fa;
        }
        .message {
            margin-bottom: 12px;
            padding: 10px 14px;
            border-radius: 12px;
            max-width: 80%;
        }
        .message.user {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
        }
        .message.bot {
            background-color: white;
            border: 1px solid #e9ecef;
        }
        .contract-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .contract-card {
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.3s;
            background: white;
        }
        .contract-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }
        .contract-card.suggested {
            border-color: #28a745;
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
        }
        .extracted-data-badge {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
        }
        .transaction-select {
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
        }
        .transaction-select:focus {
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }
        .contract-preview-full {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 30px;
            min-height: 500px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 10px;
        }
        .typing-indicator span {
            width: 8px;
            height: 8px;
            background-color: #667eea;
            border-radius: 50%;
            animation: typing 1s infinite;
        }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typing {
            0%, 100% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1); }
        }
        .btn-preview {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            border: none;
            color: white;
        }
        .btn-preview:hover {
            background: linear-gradient(135deg, #138496 0%, #117a8b 100%);
            color: white;
        }
        .btn-use-template {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            border: none;
            color: white;
            font-size: 18px;
            padding: 12px 30px;
        }
        .btn-use-template:hover {
            background: linear-gradient(135deg, #218838 0%, #1aa179 100%);
            color: white;
        }
        .missing-field {
            border-color: #ffc107 !important;
            background-color: #fff8e1;
        }
        .field-filled {
            border-color: #28a745 !important;
            background-color: #e8f5e9;
        }
        .contracts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }
        /* Placeholder styling for contract preview */
        .placeholder-inline {
            display: inline;
            background: transparent;
            color: inherit;
            padding: 0;
            border-radius: 0;
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            cursor: default;
            height: auto;
            line-height: inherit;
            margin: 0;
            box-shadow: none;
            white-space: normal;
            vertical-align: baseline;
        }
        .placeholder-inline .remove-placeholder-inline {
            display: none;
        }
        /* Filled value styling - show actual data, inherit ALL styles */
        .filled-value {
            color: inherit !important;
            font-weight: inherit !important;
            font-family: inherit !important;
            font-size: inherit !important;
            font-style: inherit !important;
            text-decoration: inherit !important;
            background: none !important;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
            display: inline !important;
        }
        /* Missing placeholder styling - highlight missing fields */
        .missing-placeholder {
            background-color: #fff3cd;
            color: #856404;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            border: 1px dashed #ffc107;
            cursor: help;
        }
        .extracted-data-badge {
            cursor: pointer;
            transition: all 0.3s;
        }
        .extracted-data-badge:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }
        .extracted-info-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
        }
        .extracted-info-table tr:last-child td {
            border-bottom: none;
        }
        .party-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
    </style>
    <script src="js/auth.js"></script>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar text-white p-3" id="sidebarMenu">
        <!-- Menu will be generated by JS -->
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Chat Section (Top) -->
        <div class="chat-section">
            <div class="row align-items-center mb-3">
                <div class="col-md-4">
                    <h5 class="mb-0">
                        <i class="bi bi-robot me-2"></i>Chat AI - T·∫°o H·ª£p ƒë·ªìng
                    </h5>
                </div>
                <div class="col-md-5">
                    <select class="form-select transaction-select" id="transactionType" onchange="onTransactionTypeChange()">
                        <option value="">‚Äî Ch·ªçn lo·∫°i giao d·ªãch ‚Äî</option>
                        <option value="gd01">1. VƒÉn b·∫£n l·ª±a ch·ªçn ng∆∞·ªùi gi√°m h·ªô</option>
                        <option value="gd02">2. VƒÉn b·∫£n t·∫∑ng cho b·∫•t ƒë·ªông s·∫£n</option>
                        <option value="gd03">3. Di ch√∫c c·ªßa ng∆∞·ªùi h·∫°n ch·∫ø th·ªÉ ch·∫•t / kh√¥ng bi·∫øt ch·ªØ</option>
                        <option value="gd04">4. VƒÉn b·∫£n ·ªßy quy·ªÅn ƒë·∫°i di·ªán kh√°ng c√°o v·ª• vi·ªác d√¢n s·ª±</option>
                        <option value="gd05">5. Hƒê mua b√°n / thu√™ mua nh√† ·ªü, c√¥ng tr√¨nh (gi·ªØa c√° nh√¢n)</option>
                        <option value="gd06">6. Hƒê giao d·ªãch nh√† ·ªü (mua b√°n, thu√™ mua, t·∫∑ng cho, ƒë·ªïi, g√≥p v·ªën, th·∫ø ch·∫•p)</option>
                        <option value="gd07">7. VƒÉn b·∫£n th·ª´a k·∫ø nh√† ·ªü</option>
                        <option value="gd08">8. Hƒê chuy·ªÉn nh∆∞·ª£ng / t·∫∑ng cho / th·∫ø ch·∫•p / g√≥p v·ªën QSDƒê</option>
                        <option value="gd09">9. VƒÉn b·∫£n v·ªÅ th·ª´a k·∫ø QSDƒê, t√†i s·∫£n g·∫Øn li·ªÅn</option>
                        <option value="gd10">10. Gi·∫•y t·ªù mua b√°n / t·∫∑ng cho / ƒë·ªïi / th·ª´a k·∫ø nh√† ·ªü tr∆∞·ªõc 01/7/2006</option>
                        <option value="gd11">11. Hƒê thu√™ ƒë·∫•t / g√≥p v·ªën / h·ª£p t√°c x√¢y d·ª±ng nh√† ·ªü</option>
                        <option value="gd12">12. Hƒê thu√™ ƒë·∫•t / g√≥p v·ªën / h·ª£p t√°c x√¢y d·ª±ng c√¥ng tr√¨nh</option>
                        <option value="gd13">13. VƒÉn b·∫£n th·ªèa thu·∫≠n t√†i s·∫£n v·ª£ ch·ªìng tr∆∞·ªõc khi k·∫øt h√¥n</option>
                        <option value="gd14">14. VƒÉn b·∫£n th·ªèa thu·∫≠n v·ªÅ vi·ªác mang thai h·ªô</option>
                        <option value="gd15">15. VƒÉn b·∫£n s·ª≠a ƒë·ªïi th·ªèa thu·∫≠n t√†i s·∫£n v·ª£ ch·ªìng</option>
                        <option value="gd16">16. H·ª£p ƒë·ªìng cho thu√™ doanh nghi·ªáp t∆∞ nh√¢n</option>
                        <option value="gd17">17. VƒÉn b·∫£n ·ªßy quy·ªÅn kh√°ng c√°o v·ª• vi·ªác h√†nh ch√≠nh</option>
                        <option value="gd18">18. VƒÉn b·∫£n ·ªßy quy·ªÅn mua nh√† ·ªü c≈© thu·ªôc t√†i s·∫£n c√¥ng</option>
                        <option value="gd19">19. H·ª£p ƒë·ªìng chuy·ªÉn nh∆∞·ª£ng kinh doanh b·∫•t ƒë·ªông s·∫£n</option>
                        <option value="gd20">20. VƒÉn b·∫£n th·ªèa thu·∫≠n ƒë∆∞a QSDƒê v√†o doanh nghi·ªáp</option>
                        <option value="gd21">21. VƒÉn b·∫£n ·ªßy quy·ªÅn thi h√†nh √°n khi xu·∫•t c·∫£nh</option>
                        <option value="gd22">22. VƒÉn b·∫£n ·ªßy quy·ªÅn th·ª±c hi·ªán quy·ªÅn khi·∫øu n·∫°i</option>
                        <option value="gd23">23. H·ª£p ƒë·ªìng chuy·ªÉn nh∆∞·ª£ng VƒÉn ph√≤ng Th·ª´a ph√°t l·∫°i</option>
                        <option value="gd24">24. C√°c giao d·ªãch kh√°c</option>
                    </select>
                </div>
                <div class="col-md-3 text-end">
                    <span id="extractedDataInfo" class="extracted-data-badge" style="display: none;" onclick="showExtractedDataModal()" title="Nh·∫•n ƒë·ªÉ xem chi ti·∫øt">
                        <i class="bi bi-check-circle me-1"></i>
                        <span id="extractedDataCount">0</span> th√¥ng tin ƒë√£ tr√≠ch xu·∫•t
                    </span>
                    <button class="btn btn-sm btn-outline-danger ms-2" onclick="clearChat()">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            </div>
            
            <div class="chat-container mb-3" id="chatContainer">
                <!-- Messages will be added here -->
            </div>

            <div class="input-group">
                <input type="text" 
                       class="form-control" 
                       id="chatInput" 
                       placeholder="M√¥ t·∫£ nhu c·∫ßu c·ªßa b·∫°n... (VD: T√¥i mu·ªën cho thu√™ cƒÉn h·ªô 50m2 t·∫°i qu·∫≠n 1)"
                       onkeypress="handleKeyPress(event)">
                <button class="btn btn-primary" onclick="sendMessage()" id="sendBtn">
                    <i class="bi bi-send-fill me-1"></i> G·ª≠i
                </button>
            </div>
        </div>

        <!-- Contract Section (Bottom) -->
        <div class="contract-section">
            <!-- Contract List with Preview Buttons -->
            <div id="contractListSection">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h5 class="mb-0">
                        <i class="bi bi-file-earmark-text me-2"></i>M·∫´u h·ª£p ƒë·ªìng
                    </h5>
                    <button class="btn btn-outline-primary btn-sm" onclick="showAvailableContracts()">
                        <i class="bi bi-list-ul me-1"></i>Xem t·∫•t c·∫£ m·∫´u
                    </button>
                </div>
                
                <div id="contractsContainer">
                    <div class="text-center text-muted py-4" id="defaultContractState">
                        <i class="bi bi-chat-left-text" style="font-size: 40px;"></i>
                        <p class="mt-2 mb-0">Chat v·ªõi AI ƒë·ªÉ ƒë∆∞·ª£c g·ª£i √Ω m·∫´u h·ª£p ƒë·ªìng ph√π h·ª£p</p>
                    </div>
                    <div id="contractsList" class="contracts-grid"></div>
                </div>
            </div>

            <!-- Full Contract Preview -->
            <div id="contractPreviewFull" style="display: none;">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <div>
                        <button class="btn btn-outline-secondary btn-sm me-2" onclick="backToContractList()">
                            <i class="bi bi-arrow-left me-1"></i>Quay l·∫°i
                        </button>
                        <span class="badge bg-info fs-6">Xem tr∆∞·ªõc m·∫´u h·ª£p ƒë·ªìng</span>
                    </div>
                    <h5 id="previewContractName" class="text-primary mb-0"></h5>
                </div>
                <div class="contract-preview-full mb-3" id="contractPreviewContent"></div>
                <div class="text-center">
                    <button class="btn btn-use-template" onclick="confirmSelectContract()">
                        <i class="bi bi-check-circle me-2"></i>D√πng m·∫´u n√†y
                    </button>
                </div>
            </div>

            <!-- Missing Fields Form -->
            <div id="missingFieldsSection" style="display: none;">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <div>
                        <button class="btn btn-outline-secondary btn-sm me-2" onclick="backToPreview()">
                            <i class="bi bi-arrow-left me-1"></i>Quay l·∫°i
                        </button>
                        <span class="badge bg-warning text-dark fs-6">ƒêi·ªÅn th√¥ng tin v√†o h·ª£p ƒë·ªìng</span>
                    </div>
                    <h5 id="selectedContractName" class="text-primary mb-0"></h5>
                </div>
                <div class="row">
                    <div class="col-md-6">
                        <div class="alert alert-info">
                            <i class="bi bi-info-circle me-2"></i>
                            Vui l√≤ng ƒëi·ªÅn c√°c th√¥ng tin c√≤n thi·∫øu ƒë·ªÉ ho√†n th√†nh h·ª£p ƒë·ªìng
                        </div>
                        <div id="missingFieldsList"></div>
                        <button class="btn btn-primary w-100 mt-3" onclick="submitMissingFields()">
                            <i class="bi bi-check-lg me-2"></i>Ho√†n th√†nh v√† t·∫°o h·ª£p ƒë·ªìng
                        </button>
                    </div>
                    <div class="col-md-6">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <h6 class="text-muted mb-0">Xem tr∆∞·ªõc h·ª£p ƒë·ªìng:</h6>
                            <button class="btn btn-outline-primary btn-sm" onclick="openFullPreviewModal()">
                                <i class="bi bi-arrows-fullscreen me-1"></i>Xem to√†n b·ªô
                            </button>
                        </div>
                        <div class="contract-preview-full" id="contractPreviewWhileFilling" style="max-height: 400px;"></div>
                    </div>
                </div>
            </div>

            <!-- Full Preview Modal -->
            <div class="modal fade" id="fullPreviewModal" tabindex="-1">
                <div class="modal-dialog modal-xl modal-dialog-scrollable">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title text-primary">
                                <i class="bi bi-file-earmark-text me-2"></i>Xem tr∆∞·ªõc h·ª£p ƒë·ªìng
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="contract-preview-full" id="contractPreviewModalContent" style="max-height: none;"></div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">ƒê√≥ng</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Final Contract -->
            <div id="contractFinalSection" style="display: none;">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <span class="badge bg-success fs-6">
                        <i class="bi bi-check-circle me-1"></i>H·ª£p ƒë·ªìng ƒë√£ ho√†n th√†nh
                    </span>
                    <div>
                        <button class="btn btn-primary me-2" onclick="downloadContract()">
                            <i class="bi bi-download me-2"></i>T·∫£i xu·ªëng Word
                        </button>
                        <button class="btn btn-outline-secondary" onclick="printContract()">
                            <i class="bi bi-printer me-2"></i>In h·ª£p ƒë·ªìng
                        </button>
                    </div>
                </div>
                <div class="contract-preview-full" id="contractFinalPreview"></div>
            </div>
        </div>
    </div>

    <!-- Modal hi·ªÉn th·ªã th√¥ng tin ƒë√£ tr√≠ch xu·∫•t -->
    <div class="modal fade" id="extractedDataModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header bg-success text-white">
                    <h5 class="modal-title">
                        <i class="bi bi-card-checklist me-2"></i>Th√¥ng tin ƒë√£ tr√≠ch xu·∫•t
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body" id="extractedDataModalBody">
                    <!-- Content will be generated -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">ƒê√≥ng</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // ========== CONFIGURATION ==========
        const CONTRACTS_DB_API = window.location.origin + '/api/contracts-db.php';
        const N8N_WEBHOOK_URL = 'https://demo.vnlawai.com/webhook/luongtuvan';
        const GEMINI_API_KEY = 'AIzaSyDisMcMHdvNMHvW36-CkMoT8w0qrqJjC-Y';
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash-latest:generateContent';

        // ========== STATE ==========
        let extractedData = {};
        let availableContracts = [];
        let selectedContract = null;
        let previewingContract = null;
        let filledData = {};
        let missingFields = [];
        let chatHistory = [];
        let selectedTransactionType = '';
        let selectedTransactionText = '';

        // ========== INITIALIZATION ==========
        window.addEventListener('load', async () => {
            // Check auth and generate sidebar
            if (!initPage('user-chat')) return;
            document.getElementById('sidebarMenu').innerHTML = generateSidebar('user-chat');
            
            loadExtractedData();
            await loadAvailableContracts();
            
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('fromExtract') === 'true') {
                // Show welcome message with extracted data
                showWelcomeWithData();
            } else {
                // Show default welcome
                showDefaultWelcome();
            }
        });

        function loadExtractedData() {
            const stored = sessionStorage.getItem('extractedData');
            if (stored) {
                const data = JSON.parse(stored);
                extractedData = data;
                
                // Flatten data for easier use
                filledData = flattenExtractedData(data);
                
                // Count actual unique fields (not variations)
                const actualCount = countActualFields(data);
                if (actualCount > 0) {
                    document.getElementById('extractedDataInfo').style.display = 'block';
                    document.getElementById('extractedDataCount').textContent = actualCount;
                }
            }
        }

        // Count actual unique fields from extracted data
        function countActualFields(data) {
            let count = 0;
            
            // Count CCCD fields
            if (data.cccd) {
                Object.values(data.cccd).forEach(info => {
                    Object.values(info).forEach(value => {
                        if (value) count++;
                    });
                });
            }
            
            // Count other document fields
            if (data.other) {
                Object.values(data.other).forEach(info => {
                    Object.values(info).forEach(value => {
                        if (value) count++;
                    });
                });
            }
            
            return count;
        }

        // Show modal with extracted data details
        function showExtractedDataModal() {
            const modalBody = document.getElementById('extractedDataModalBody');
            let html = '';
            
            // Field labels in Vietnamese
            const fieldLabels = {
                fullname: 'H·ªç v√† t√™n',
                birthday: 'Ng√†y sinh',
                idcard: 'S·ªë CMND/CCCD',
                issue_date: 'Ng√†y c·∫•p',
                issuing_authority: 'C∆° quan c·∫•p',
                expiry_date: 'Ng√†y h·∫øt h·∫°n',
                address: 'ƒê·ªãa ch·ªâ',
                phone: 'S·ªë ƒëi·ªán tho·∫°i',
                email: 'Email'
            };
            
            // Display CCCD data
            if (extractedData.cccd) {
                Object.entries(extractedData.cccd).forEach(([party, info]) => {
                    html += `<div class="mb-4">
                        <div class="party-header">
                            <i class="bi bi-person-badge me-2"></i>Th√¥ng tin ƒê∆∞∆°ng s·ª± ${party}
                        </div>
                        <table class="table table-sm extracted-info-table mb-0">`;
                    
                    Object.entries(info).forEach(([key, value]) => {
                        if (value) {
                            const label = fieldLabels[key] || key;
                            html += `<tr>
                                <td class="text-muted" style="width: 40%">${label}</td>
                                <td><strong>${value}</strong></td>
                            </tr>`;
                        }
                    });
                    
                    html += `</table></div>`;
                });
            }
            
            // Display other document data
            if (extractedData.other && Object.keys(extractedData.other).length > 0) {
                Object.entries(extractedData.other).forEach(([party, info]) => {
                    html += `<div class="mb-4">
                        <div class="party-header">
                            <i class="bi bi-file-text me-2"></i>Gi·∫•y t·ªù kh√°c - ƒê∆∞∆°ng s·ª± ${party}
                        </div>
                        <table class="table table-sm extracted-info-table mb-0">`;
                    
                    Object.entries(info).forEach(([key, value]) => {
                        if (value) {
                            html += `<tr>
                                <td class="text-muted" style="width: 40%">${key}</td>
                                <td><strong>${value}</strong></td>
                            </tr>`;
                        }
                    });
                    
                    html += `</table></div>`;
                });
            }
            
            if (!html) {
                html = '<p class="text-muted text-center">Ch∆∞a c√≥ th√¥ng tin n√†o ƒë∆∞·ª£c tr√≠ch xu·∫•t</p>';
            }
            
            modalBody.innerHTML = html;
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('extractedDataModal'));
            modal.show();
        }

        function flattenExtractedData(data) {
            const flattened = {};
            
            // Map English keys to Vietnamese variations
            const keyVariations = {
                'issue_date': ['issue_date', 'ngay_cap', 'ngaycap'],
                'expiry_date': ['expiry_date', 'ngay_het_han', 'ngayhethan'],
                'fullname': ['fullname', 'ho_va_ten', 'hovaten', 'ho_ten', 'hoten'],
                'birthday': ['birthday', 'ngay_sinh', 'ngaysinh'],
                'idcard': ['idcard', 'so_cccd', 'socccd', 'so_cmnd', 'socmnd', 'cccd', 'cmnd'],
                'address': ['address', 'dia_chi', 'diachi', 'noi_dktt', 'noidktt'],
                'phone': ['phone', 'dien_thoai', 'dienthoai', 'so_dien_thoai'],
                'email': ['email'],
                'issuing_authority': ['issuing_authority', 'co_quan_cap', 'coquancap', 'noi_cap', 'noicap']
            };
            
            // Process CCCD data
            if (data.cccd) {
                Object.entries(data.cccd).forEach(([party, info]) => {
                    Object.entries(info).forEach(([key, value]) => {
                        if (value) {
                            const partyLower = party.toLowerCase();
                            
                            // Get all variations for this key
                            const variations = keyVariations[key] || [key];
                            
                            // Create entries for each variation
                            variations.forEach(varKey => {
                                flattened[`${varKey}_${partyLower}`] = value;
                                flattened[`${varKey}_ben_${partyLower}`] = value;
                                
                                if (party === 'A') {
                                    flattened[varKey] = value; // Default to first party
                                    flattened[`${varKey}_ben_a`] = value;
                                }
                                if (party === 'B') {
                                    flattened[`${varKey}_ben_b`] = value;
                                }
                            });
                        }
                    });
                });
            }
            
            // Process other document data
            if (data.other) {
                Object.entries(data.other).forEach(([party, info]) => {
                    Object.entries(info).forEach(([key, value]) => {
                        if (value) {
                            const partyLower = party.toLowerCase();
                            const variations = keyVariations[key] || [key];
                            
                            variations.forEach(varKey => {
                                flattened[`${varKey}_${partyLower}`] = value;
                                flattened[`${varKey}_ben_${partyLower}`] = value;
                            });
                        }
                    });
                });
            }
            
            console.log('Flattened data:', flattened);
            return flattened;
        }

        // ========== AI MAPPING FUNCTIONS ==========
        let aiMappedData = {}; // Store AI-mapped data
        
        // Use AI to map extracted data to contract placeholders
        async function aiMapDataToPlaceholders(placeholders, extractedInfo) {
            console.log('ü§ñ Starting AI mapping...');
            console.log('Placeholders:', placeholders);
            console.log('Extracted data:', extractedInfo);
            
            // Prepare extracted data summary
            const extractedSummary = {};
            if (extractedInfo.cccd) {
                Object.entries(extractedInfo.cccd).forEach(([party, data]) => {
                    extractedSummary[`ƒê∆∞∆°ng s·ª± ${party}`] = data;
                });
            }
            
            const prompt = `B·∫°n l√† tr·ª£ l√Ω AI chuy√™n v·ªÅ h·ª£p ƒë·ªìng ph√°p l√Ω Vi·ªát Nam.

NHI·ªÜM V·ª§: Map (gh√©p n·ªëi) th√¥ng tin ƒë√£ tr√≠ch xu·∫•t t·ª´ CCCD v√†o c√°c placeholder trong h·ª£p ƒë·ªìng.

TH√îNG TIN ƒê√É TR√çCH XU·∫§T:
${JSON.stringify(extractedSummary, null, 2)}

C√ÅC PLACEHOLDER C·∫¶N ƒêI·ªÄN (t√™n bi·∫øn trong h·ª£p ƒë·ªìng):
${placeholders.map(p => `- ${p.field} (${p.label || p.field})`).join('\n')}

QUY T·∫ÆC:
1. ƒê∆∞∆°ng s·ª± A th∆∞·ªùng l√† B√äN B√ÅN/B√äN CHO THU√ä/B√äN CHUY·ªÇN NH∆Ø·ª¢NG
2. ƒê∆∞∆°ng s·ª± B th∆∞·ªùng l√† B√äN MUA/B√äN THU√ä/B√äN NH·∫¨N CHUY·ªÇN NH∆Ø·ª¢NG
3. C√°c field c√≥ "_ben_a", "_b√™n_A", "_A" cu·ªëi t√™n ‚Üí l·∫•y t·ª´ ƒê∆∞∆°ng s·ª± A
4. C√°c field c√≥ "_ben_b", "_b√™n_B", "_B" cu·ªëi t√™n ‚Üí l·∫•y t·ª´ ƒê∆∞∆°ng s·ª± B
5. fullname/H·ªç_v√†_t√™n ‚Üí l·∫•y t·ª´ fullname
6. idcard/CMND/CCCD/s·ªë_cmnd ‚Üí l·∫•y t·ª´ idcard
7. address/ƒë·ªãa_ch·ªâ/n∆°i_ƒêKTT ‚Üí l·∫•y t·ª´ address
8. birthday/ng√†y_sinh ‚Üí l·∫•y t·ª´ birthday
9. issue_date/ng√†y_c·∫•p ‚Üí l·∫•y t·ª´ issue_date
10. N·∫øu kh√¥ng c√≥ th√¥ng tin ph√π h·ª£p ‚Üí ƒë·ªÉ null

TR·∫¢ V·ªÄ JSON v·ªõi format:
{
  "mapping": {
    "t√™n_placeholder": "gi√°_tr·ªã_t·ª´_d·ªØ_li·ªáu_tr√≠ch_xu·∫•t_ho·∫∑c_null"
  }
}

CH·ªà TR·∫¢ V·ªÄ JSON, KH√îNG C√ì TEXT KH√ÅC.`;

            try {
                const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.1,
                            maxOutputTokens: 2048
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                
                console.log('ü§ñ AI Response:', text);
                
                // Parse JSON from response
                const jsonMatch = text.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    if (result.mapping) {
                        // Merge AI mapping into filledData
                        Object.entries(result.mapping).forEach(([key, value]) => {
                            if (value && value !== 'null' && value !== null) {
                                aiMappedData[key] = value;
                                filledData[key] = value;
                            }
                        });
                        console.log('‚úÖ AI Mapping successful:', aiMappedData);
                        return true;
                    }
                }
                
                console.log('‚ö†Ô∏è Could not parse AI response');
                return false;
                
            } catch (error) {
                console.error('‚ùå AI Mapping error:', error);
                return false;
            }
        }
        
        // Get value with AI mapping fallback
        function getValueForFieldWithAI(field) {
            // First check AI mapped data
            if (aiMappedData[field]) {
                return aiMappedData[field];
            }
            // Then fall back to regular matching
            return getValueForField(field);
        }

        async function loadAvailableContracts() {
            try {
                const response = await fetch(CONTRACTS_DB_API);
                const data = await response.json();
                
                if (Array.isArray(data)) {
                    availableContracts = data;
                    console.log(`Loaded ${availableContracts.length} contracts from database`);
                }
            } catch (error) {
                console.error('Error loading contracts:', error);
            }
        }

        // ========== CHAT FUNCTIONS ==========
        function showDefaultWelcome() {
            const hasData = Object.keys(filledData).length > 0;
            
            if (hasData) {
                const partyCount = Object.keys(extractedData.cccd || {}).length;
                addBotMessage(`Xin ch√†o! T√¥i ƒë√£ nh·∫≠n ƒë∆∞·ª£c th√¥ng tin t·ª´ ${partyCount} ƒë∆∞∆°ng s·ª±.

üìã **Th√¥ng tin ƒë√£ c√≥:**
${Object.entries(extractedData.cccd || {}).map(([party, data]) => 
    `‚Ä¢ ƒê∆∞∆°ng s·ª± ${party}: ${data.fullname || 'N/A'}`
).join('\n')}

**ƒê·ªÉ ƒë∆∞·ª£c t∆∞ v·∫•n ph√°p l√Ω, b·∫°n h√£y:**
1Ô∏è‚É£ Ch·ªçn **lo·∫°i giao d·ªãch** ·ªü dropdown ph√≠a tr√™n
2Ô∏è‚É£ M√¥ t·∫£ chi ti·∫øt **nhu c·∫ßu** c·ªßa b·∫°n
3Ô∏è‚É£ T√¥i s·∫Ω t∆∞ v·∫•n v√† g·ª£i √Ω h·ª£p ƒë·ªìng ph√π h·ª£p`);
            } else {
                addBotMessage(`Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI t∆∞ v·∫•n ph√°p l√Ω.

**ƒê·ªÉ b·∫Øt ƒë·∫ßu, b·∫°n h√£y:**
1Ô∏è‚É£ Ch·ªçn **lo·∫°i giao d·ªãch** ·ªü dropdown ph√≠a tr√™n
2Ô∏è‚É£ M√¥ t·∫£ chi ti·∫øt **nhu c·∫ßu** c·ªßa b·∫°n (VD: "T√¥i mu·ªën cho thu√™ cƒÉn h·ªô 50m2 t·∫°i qu·∫≠n 1")
3Ô∏è‚É£ T√¥i s·∫Ω **t∆∞ v·∫•n ph√°p l√Ω** v√† g·ª£i √Ω m·∫´u h·ª£p ƒë·ªìng ph√π h·ª£p

üí° *M√¥ t·∫£ c√†ng chi ti·∫øt, t∆∞ v·∫•n c√†ng ch√≠nh x√°c!*`);
            }
        }

        function showWelcomeWithData() {
            showDefaultWelcome();
        }

        function onTransactionTypeChange() {
            const select = document.getElementById('transactionType');
            selectedTransactionType = select.value;
            selectedTransactionText = select.options[select.selectedIndex].text;
            
            if (selectedTransactionType) {
                addBotMessage(`‚úÖ B·∫°n ƒë√£ ch·ªçn: **${selectedTransactionText}**

B√¢y gi·ªù h√£y m√¥ t·∫£ chi ti·∫øt nhu c·∫ßu c·ªßa b·∫°n. V√≠ d·ª•:
‚Ä¢ C√°c b√™n tham gia l√† ai?
‚Ä¢ T√†i s·∫£n/ƒë·ªëi t∆∞·ª£ng giao d·ªãch l√† g√¨?
‚Ä¢ Gi√° tr·ªã, th·ªùi h·∫°n, ƒëi·ªÅu ki·ªán ƒë·∫∑c bi·ªát?

T√¥i s·∫Ω t∆∞ v·∫•n ph√°p l√Ω v√† g·ª£i √Ω m·∫´u h·ª£p ƒë·ªìng ph√π h·ª£p!`);
            }
        }

        function addBotMessage(text, isHtml = false) {
            const container = document.getElementById('chatContainer');
            const div = document.createElement('div');
            div.className = 'message bot';
            
            if (isHtml) {
                div.innerHTML = `
                    <div class="d-flex align-items-start">
                        <i class="bi bi-robot me-2" style="font-size: 20px; color: #667eea;"></i>
                        <div class="flex-grow-1">${text}</div>
                    </div>
                `;
            } else {
                div.innerHTML = `
                    <div class="d-flex align-items-start">
                        <i class="bi bi-robot me-2" style="font-size: 20px; color: #667eea;"></i>
                        <div class="flex-grow-1">${text.replace(/\n/g, '<br>').replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')}</div>
                    </div>
                `;
            }
            
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
            
            chatHistory.push({ role: 'bot', content: text });
        }

        function addUserMessage(text) {
            const container = document.getElementById('chatContainer');
            const div = document.createElement('div');
            div.className = 'message user';
            div.innerHTML = `<div>${text}</div>`;
            
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
            
            chatHistory.push({ role: 'user', content: text });
        }

        function showTypingIndicator() {
            const container = document.getElementById('chatContainer');
            const div = document.createElement('div');
            div.className = 'message bot';
            div.id = 'typingIndicator';
            div.innerHTML = `
                <div class="typing-indicator">
                    <span></span><span></span><span></span>
                </div>
            `;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (indicator) indicator.remove();
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            addUserMessage(message);
            input.value = '';
            
            showTypingIndicator();
            
            try {
                await processUserMessage(message);
            } catch (error) {
                console.error('Error processing message:', error);
                addBotMessage('Xin l·ªói, ƒë√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.');
            }
            
            hideTypingIndicator();
        }

        async function processUserMessage(message) {
            // Check if transaction type is selected
            if (!selectedTransactionType) {
                addBotMessage(`‚ö†Ô∏è Vui l√≤ng **ch·ªçn lo·∫°i giao d·ªãch** t·ª´ dropdown ph√≠a tr√™n tr∆∞·ªõc khi chat.`);
                return;
            }
            
            // Always do both: n8n consultation + AI contract suggestion
            await processFullRequest(message);
        }

        // Process full request: n8n consultation + AI contract suggestions
        async function processFullRequest(message) {
            try {
                // Step 1: Get legal consultation from n8n
                let consultationMessage = '';
                try {
                    const n8nResponse = await fetch(N8N_WEBHOOK_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: message,
                            transactionType: selectedTransactionType
                        })
                    });

                    if (n8nResponse.ok) {
                        const n8nData = await n8nResponse.json();
                        consultationMessage = n8nData.message || n8nData.response || n8nData.output || '';
                        if (typeof n8nData === 'string') consultationMessage = n8nData;
                    }
                } catch (e) {
                    console.error('N8N Error:', e);
                }

                // Display consultation if available
                if (consultationMessage) {
                    addBotMessage(`üìã **T∆∞ v·∫•n ph√°p l√Ω:**\n\n${consultationMessage}`);
                }

                // Step 2: Use AI to suggest contracts
                await suggestContractsWithAI(message);
                
            } catch (error) {
                console.error('Error processing request:', error);
                addBotMessage('Xin l·ªói, ƒë√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.');
            }
        }

        // Internal AI to suggest contracts from database
        async function suggestContractsWithAI(message) {
            try {
                // Build contract list
                const contractList = availableContracts.map((c, i) => `${i + 1}. ${c.name}`).join('\n');
                
                const prompt = `B·∫°n l√† tr·ª£ l√Ω AI g·ª£i √Ω h·ª£p ƒë·ªìng.

LO·∫†I GIAO D·ªäCH: ${selectedTransactionText}
Y√äU C·∫¶U NG∆Ø·ªúI D√ôNG: ${message}

DANH S√ÅCH M·∫™U H·ª¢P ƒê·ªíNG C√ì S·∫¥N:
${contractList || 'Ch∆∞a c√≥ m·∫´u h·ª£p ƒë·ªìng n√†o'}

NHI·ªÜM V·ª§:
1. D·ª±a v√†o lo·∫°i giao d·ªãch v√† y√™u c·∫ßu, ch·ªçn 1-3 m·∫´u h·ª£p ƒë·ªìng ph√π h·ª£p nh·∫•t
2. Gi·∫£i th√≠ch ng·∫Øn g·ªçn t·∫°i sao ph√π h·ª£p

TR·∫¢ L·ªúI FORMAT JSON:
{
    "message": "L·ªùi gi·ªõi thi·ªáu ng·∫Øn",
    "suggestions": [
        {"index": 1, "reason": "L√Ω do ph√π h·ª£p"}
    ]
}

N·∫øu kh√¥ng c√≥ m·∫´u ph√π h·ª£p, tr·∫£ v·ªÅ suggestions r·ªóng v√† g·ª£i √Ω li√™n h·ªá Admin.`;

                const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.3, maxOutputTokens: 800 }
                    })
                });

                const data = await response.json();
                const aiText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                
                // Parse AI response
                const jsonMatch = aiText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    
                    addBotMessage(result.message || 'ƒê√¢y l√† c√°c m·∫´u h·ª£p ƒë·ªìng ph√π h·ª£p:');
                    
                    if (result.suggestions && result.suggestions.length > 0) {
                        // Show suggested contracts
                        const suggestedContracts = result.suggestions
                            .filter(s => s.index > 0 && s.index <= availableContracts.length)
                            .map(s => ({
                                ...availableContracts[s.index - 1],
                                reason: s.reason
                            }));
                        
                        if (suggestedContracts.length > 0) {
                            showSuggestedContracts(suggestedContracts);
                        } else {
                            showAvailableContracts();
                        }
                    } else {
                        showAvailableContracts();
                    }
                } else {
                    // Fallback: show all contracts
                    addBotMessage('ƒê√¢y l√† c√°c m·∫´u h·ª£p ƒë·ªìng c√≥ s·∫µn trong h·ªá th·ªëng:');
                    showAvailableContracts();
                }
                
            } catch (error) {
                console.error('AI Suggestion Error:', error);
                addBotMessage('ƒê√¢y l√† c√°c m·∫´u h·ª£p ƒë·ªìng c√≥ s·∫µn:');
                showAvailableContracts();
            }
        }

        // Show AI suggested contracts with reasons
        function showSuggestedContracts(contracts) {
            document.getElementById('defaultContractState').style.display = 'none';
            const container = document.getElementById('contractsList');
            container.innerHTML = '';
            
            contracts.forEach((contract) => {
                const card = document.createElement('div');
                card.className = 'contract-card suggested';
                card.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <h6 class="mb-1 text-success">
                                <i class="bi bi-star-fill me-2"></i>${contract.name}
                            </h6>
                            <p class="mb-2 small text-muted">${contract.reason || 'Ph√π h·ª£p v·ªõi y√™u c·∫ßu c·ªßa b·∫°n'}</p>
                        </div>
                        <button class="btn btn-preview btn-sm" onclick="previewContract(${contract.id})">
                            <i class="bi bi-eye me-1"></i>Xem tr∆∞·ªõc
                        </button>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function findMatchingContracts(query) {
            const lowerQuery = query.toLowerCase();
            const keywords = lowerQuery.split(/\s+/);
            
            return availableContracts.filter(contract => {
                const name = contract.name.toLowerCase();
                return keywords.some(keyword => 
                    keyword.length > 2 && name.includes(keyword)
                );
            });
        }

        function showContractOptions(contracts, userQuery) {
            if (contracts.length === 1) {
                addBotMessage(`T√¥i t√¨m th·∫•y m·∫´u h·ª£p ƒë·ªìng ph√π h·ª£p: **${contracts[0].name}**
                
B·∫°n c√≥ mu·ªën s·ª≠ d·ª•ng m·∫´u n√†y kh√¥ng?`);
            } else {
                addBotMessage(`T√¥i t√¨m th·∫•y ${contracts.length} m·∫´u h·ª£p ƒë·ªìng ph√π h·ª£p. Vui l√≤ng ch·ªçn m·ªôt m·∫´u:`);
            }
            
            showContractSelection(contracts);
        }

        function showAvailableContracts() {
            if (availableContracts.length === 0) {
                addBotMessage('Hi·ªán t·∫°i ch∆∞a c√≥ m·∫´u h·ª£p ƒë·ªìng n√†o trong h·ªá th·ªëng. Vui l√≤ng li√™n h·ªá Admin ƒë·ªÉ th√™m m·∫´u.');
                return;
            }
            
            addBotMessage(`üìÇ C√≥ ${availableContracts.length} m·∫´u h·ª£p ƒë·ªìng trong h·ªá th·ªëng. Ch·ªçn m·∫´u ƒë·ªÉ xem tr∆∞·ªõc.`);
            showContractSelection(availableContracts);
        }

        function showContractSelection(contracts) {
            document.getElementById('defaultContractState').style.display = 'none';
            const container = document.getElementById('contractsList');
            container.innerHTML = '';
            
            contracts.forEach((contract) => {
                const card = document.createElement('div');
                card.className = 'contract-card';
                card.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="flex-grow-1">
                            <h6 class="mb-1">${contract.name}</h6>
                            <small class="text-muted">
                                <i class="bi bi-file-earmark me-1"></i>${contract.file_type === 'word' ? 'Word' : 'PDF'}
                                <span class="ms-2"><i class="bi bi-calendar me-1"></i>${formatDate(contract.created_at)}</span>
                            </small>
                        </div>
                        <button class="btn btn-preview btn-sm" onclick="previewContract(${contract.id})">
                            <i class="bi bi-eye me-1"></i>Xem tr∆∞·ªõc
                        </button>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        // Preview contract before selecting
        async function previewContract(contractId) {
            addBotMessage('ƒêang t·∫£i xem tr∆∞·ªõc h·ª£p ƒë·ªìng...');
            
            try {
                const response = await fetch(`${CONTRACTS_DB_API}?id=${contractId}`);
                const contract = await response.json();
                
                if (!contract || contract.error) {
                    throw new Error('Kh√¥ng th·ªÉ t·∫£i h·ª£p ƒë·ªìng');
                }
                
                previewingContract = contract;
                
                // Hide contract list, show preview
                document.getElementById('contractListSection').style.display = 'none';
                document.getElementById('contractPreviewFull').style.display = 'block';
                
                // Set contract name and content with sample data
                document.getElementById('previewContractName').textContent = contract.name;
                let content = contract.modified_content || contract.template || '<p class="text-muted">Kh√¥ng c√≥ n·ªôi dung</p>';
                
                // Replace placeholders with sample data for preview
                content = displayWithSampleData(content);
                document.getElementById('contractPreviewContent').innerHTML = content;
                
                addBotMessage(`üìÑ ƒêang xem tr∆∞·ªõc: **${contract.name}**

Xem n·ªôi dung h·ª£p ƒë·ªìng b√™n d∆∞·ªõi. N·∫øu ph√π h·ª£p, nh·∫•n **"D√πng m·∫´u n√†y"** ƒë·ªÉ ti·∫øp t·ª•c.`);
                
            } catch (error) {
                console.error('Error loading contract:', error);
                addBotMessage('L·ªói khi t·∫£i h·ª£p ƒë·ªìng. Vui l√≤ng th·ª≠ l·∫°i.');
            }
        }

        // Back to contract list from preview
        function backToContractList() {
            previewingContract = null;
            document.getElementById('contractPreviewFull').style.display = 'none';
            document.getElementById('missingFieldsSection').style.display = 'none';
            document.getElementById('contractFinalSection').style.display = 'none';
            document.getElementById('contractListSection').style.display = 'block';
            addBotMessage('Quay l·∫°i danh s√°ch h·ª£p ƒë·ªìng. Ch·ªçn m·∫´u b·∫°n mu·ªën xem.');
        }

        // Confirm select contract after preview
        async function confirmSelectContract() {
            if (!previewingContract) return;
            
            selectedContract = previewingContract;
            previewingContract = null;
            
            // Parse placeholder mappings
            let placeholders = [];
            if (selectedContract.placeholder_mappings) {
                placeholders = typeof selectedContract.placeholder_mappings === 'string' 
                    ? JSON.parse(selectedContract.placeholder_mappings) 
                    : selectedContract.placeholder_mappings;
            }
            
            // Extract from modified_content
            if (selectedContract.modified_content) {
                const regex = /data-field="([^"]+)"[^>]*data-label="([^"]*)"/g;
                let match;
                while ((match = regex.exec(selectedContract.modified_content)) !== null) {
                    const field = match[1];
                    const label = match[2] || field;
                    if (!placeholders.some(p => p.field === field)) {
                        placeholders.push({ field: field, label: label });
                    }
                }
                // Also try without label
                const regex2 = /data-field="([^"]+)"/g;
                while ((match = regex2.exec(selectedContract.modified_content)) !== null) {
                    const field = match[1];
                    if (!placeholders.some(p => p.field === field)) {
                        placeholders.push({ field: field, label: field });
                    }
                }
            }
            
            // ü§ñ Use AI to map extracted data to placeholders
            if (Object.keys(extractedData).length > 0 && placeholders.length > 0) {
                addBotMessage(`ü§ñ ƒêang s·ª≠ d·ª•ng AI ƒë·ªÉ gh√©p n·ªëi th√¥ng tin...`);
                
                const aiSuccess = await aiMapDataToPlaceholders(placeholders, extractedData);
                
                if (aiSuccess) {
                    addBotMessage(`‚úÖ AI ƒë√£ gh√©p n·ªëi th√†nh c√¥ng ${Object.keys(aiMappedData).length} tr∆∞·ªùng th√¥ng tin!`);
                }
            }
            
            // Find missing fields after AI mapping
            missingFields = findMissingFields(placeholders);
            
            if (missingFields.length > 0) {
                addBotMessage(`‚úÖ ƒê√£ ch·ªçn h·ª£p ƒë·ªìng: **${selectedContract.name}**

‚ö†Ô∏è C√≤n **${missingFields.length} th√¥ng tin** c·∫ßn b·ªï sung.
Vui l√≤ng ƒëi·ªÅn v√†o form b√™n d∆∞·ªõi.`);
                showMissingFieldsForm();
            } else {
                addBotMessage(`‚úÖ ƒê√£ ch·ªçn h·ª£p ƒë·ªìng: **${selectedContract.name}**

üéâ T·∫•t c·∫£ th√¥ng tin ƒë√£ ƒë·∫ßy ƒë·ªß! ƒêang t·∫°o h·ª£p ƒë·ªìng...`);
                generateContract();
            }
        }

        // Back to preview from missing fields form
        function backToPreview() {
            if (selectedContract) {
                previewingContract = selectedContract;
                selectedContract = null;
                
                document.getElementById('missingFieldsSection').style.display = 'none';
                document.getElementById('contractPreviewFull').style.display = 'block';
                document.getElementById('previewContractName').textContent = previewingContract.name;
                
                let content = previewingContract.modified_content || previewingContract.template || '';
                content = displayWithSampleData(content);
                document.getElementById('contractPreviewContent').innerHTML = content;
            }
        }

        async function selectContract(contractId) {
            await previewContract(contractId);
        }

        function findMissingFields(placeholders) {
            const missing = [];
            
            placeholders.forEach(placeholder => {
                const field = placeholder.field;
                const label = placeholder.label || field;
                
                // Check AI mapped data first, then fallback to getValueForField
                let value = aiMappedData[field];
                if (!value) {
                    value = getValueForField(field);
                }
                
                if (!value) {
                    missing.push({
                        field: field,
                        label: label,
                        sampleData: placeholder.sampleData || ''
                    });
                }
            });
            
            return missing;
        }

        function showMissingFieldsForm() {
            document.getElementById('contractPreviewFull').style.display = 'none';
            document.getElementById('missingFieldsSection').style.display = 'block';
            document.getElementById('selectedContractName').textContent = selectedContract.name;
            
            // Show contract preview while filling - with filled data or placeholder names
            updatePreviewWhileFilling();
            
            const container = document.getElementById('missingFieldsList');
            container.innerHTML = '';
            
            missingFields.forEach((field, index) => {
                const div = document.createElement('div');
                div.className = 'mb-3';
                div.innerHTML = `
                    <label class="form-label">
                        ${field.label}
                        <span class="text-danger">*</span>
                    </label>
                    <input type="text" 
                           class="form-control missing-field" 
                           id="field_${field.field}"
                           placeholder="Nh·∫≠p ${field.label}:"
                           data-field="${field.field}"
                           oninput="onFieldInput(this)">
                `;
                container.appendChild(div);
            });
        }
        
        // Update preview when user types in a field
        function onFieldInput(input) {
            const field = input.dataset.field;
            const value = input.value.trim();
            
            if (value) {
                filledData[field] = value;
                input.classList.remove('is-invalid');
            } else {
                delete filledData[field];
            }
            
            // Update the preview in real-time
            updatePreviewWhileFilling();
        }

        function submitMissingFields() {
            let allFilled = true;
            
            missingFields.forEach(field => {
                const input = document.getElementById(`field_${field.field}`);
                const value = input.value.trim();
                
                if (value) {
                    filledData[field.field] = value;
                    input.classList.remove('missing-field');
                    input.classList.add('field-filled');
                } else {
                    allFilled = false;
                    input.classList.add('is-invalid');
                }
            });
            
            if (!allFilled) {
                addBotMessage('‚ö†Ô∏è Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß c√°c th√¥ng tin c√≤n thi·∫øu.');
                return;
            }
            
            addBotMessage('‚úÖ ƒê√£ nh·∫≠n ƒë·ªß th√¥ng tin! ƒêang t·∫°o h·ª£p ƒë·ªìng...');
            generateContract();
        }

        function generateContract() {
            if (!selectedContract) return;
            
            document.getElementById('contractListSection').style.display = 'none';
            document.getElementById('contractPreviewFull').style.display = 'none';
            document.getElementById('missingFieldsSection').style.display = 'none';
            document.getElementById('contractFinalSection').style.display = 'block';
            
            let content = selectedContract.modified_content || selectedContract.template || '';
            
            console.log('=== GENERATE CONTRACT ===');
            console.log('FilledData:', filledData);
            console.log('AI Mapped Data:', aiMappedData);
            
            // Only replace placeholders that admin has configured
            // Method 1: Replace placeholder spans with data-field attribute
            content = content.replace(/<span[^>]*class="[^"]*placeholder-inline[^"]*"[^>]*data-field="([^"]+)"[^>]*>[\s\S]*?<\/span>/gi, 
                (match, field) => {
                    // Check AI mapped data first, then fallback to getValueForField
                    let value = aiMappedData[field];
                    if (!value) {
                        value = getValueForField(field);
                    }
                    console.log(`Field "${field}" => Value "${value}"`);
                    
                    if (value) {
                        // Replace with actual value, keep original text style (no color change)
                        return escapeHtml(value);
                    } else {
                        // Keep placeholder visible if no data
                        return `[${field}]`;
                    }
                }
            );
            
            // Method 2: Replace {{field}} syntax in template
            content = content.replace(/\{\{([^}]+)\}\}/g, (match, field) => {
                // Check AI mapped data first
                let value = aiMappedData[field.trim()];
                if (!value) {
                    value = getValueForField(field.trim());
                }
                if (value) {
                    return escapeHtml(value);
                }
                return `[${field.trim()}]`;
            });
            
            document.getElementById('contractFinalPreview').innerHTML = content || '<p class="text-muted">Kh√¥ng c√≥ n·ªôi dung h·ª£p ƒë·ªìng</p>';
            
            addBotMessage(`üéâ H·ª£p ƒë·ªìng **${selectedContract.name}** ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!

B·∫°n c√≥ th·ªÉ xem, t·∫£i xu·ªëng ho·∫∑c in h·ª£p ƒë·ªìng b√™n d∆∞·ªõi.`);
        }

        // Get value for a specific field from extracted data
        function getValueForField(field) {
            if (!field) return null;
            
            console.log(`Looking for field: "${field}"`);
            
            // 1. Exact match first
            if (filledData[field]) {
                console.log(`  -> Exact match found: ${filledData[field]}`);
                return filledData[field];
            }
            
            // 2. Case-insensitive match
            const fieldLower = field.toLowerCase();
            for (const [key, value] of Object.entries(filledData)) {
                if (key.toLowerCase() === fieldLower) {
                    console.log(`  -> Case-insensitive match: ${key} = ${value}`);
                    return value;
                }
            }
            
            // 3. Normalize Vietnamese diacritics and try matching
            const fieldNoDiacritics = removeVietnameseDiacritics(field);
            for (const [key, value] of Object.entries(filledData)) {
                if (removeVietnameseDiacritics(key) === fieldNoDiacritics) {
                    console.log(`  -> Vietnamese normalized match: ${key} = ${value}`);
                    return value;
                }
            }
            
            // 4. Try common field name mappings
            // Extract party identifier from field (e.g., fullname_ben_a -> party A, H·ªç_v√†_t√™n_b√™n_A -> party A)
            const partyMatch = field.match(/[_-]?(ben[_-]?)?([ab])$/i);
            const party = partyMatch ? partyMatch[2].toUpperCase() : null;
            
            // Get base field name without party suffix - normalize Vietnamese
            let baseField = field.replace(/[_-]?(ben[_-]?)?[ab]$/i, '');
            baseField = removeVietnameseDiacritics(baseField).replace(/_/g, '');
            
            console.log(`  -> Base field (normalized): "${baseField}", Party: "${party}"`);
            
            // Map of field aliases (all lowercase, no diacritics, no underscores)
            const aliases = {
                'fullname': ['fullname', 'hovaten', 'hoten', 'name', 'ten', 'hovat√™n', 'h·ªçvaten'],
                'birthday': ['birthday', 'ngaysinh', 'dob', 'birthdate'],
                'idcard': ['idcard', 'cccd', 'cmnd', 'id', 'socccd', 'socmnd', 'cmndcccd'],
                'address': ['address', 'diachi', 'thuongtru', 'noio', 'dktt', 'noidktt'],
                'issue_date': ['issuedate', 'ngaycap', 'ng√†y cap', 'ngayc·∫•p'],
                'expiry_date': ['expirydate', 'ngayhethan', 'ng√†yh·∫øth·∫°n'],
                'phone': ['phone', 'dienthoai', 'sdt', 'mobile', 'sodienthoai'],
                'email': ['email', 'mail'],
                'co_quan_cap': ['coquancap', 'noicap', 'c∆°quanc·∫•p', 'n∆°ic·∫•p']
            };
            
            // Find which category this field belongs to
            let matchedCategory = null;
            for (const [category, aliasList] of Object.entries(aliases)) {
                if (aliasList.some(a => baseField.includes(a) || a.includes(baseField))) {
                    matchedCategory = category;
                    break;
                }
            }
            
            if (matchedCategory) {
                console.log(`  -> Matched category: ${matchedCategory}`);
                
                // Look for data with this category and party
                for (const [key, value] of Object.entries(filledData)) {
                    const keyNormalized = removeVietnameseDiacritics(key).replace(/_/g, '');
                    const keyPartyMatch = key.match(/[_-]?([ab])$/i);
                    const keyParty = keyPartyMatch ? keyPartyMatch[1].toUpperCase() : null;
                    const keyBase = keyNormalized.replace(/[ab]$/i, '');
                    
                    // Check if this key matches our category
                    const keyMatchesCategory = aliases[matchedCategory].some(a => 
                        keyBase.includes(a) || a.includes(keyBase)
                    );
                    
                    if (keyMatchesCategory) {
                        // If field specifies a party, match party
                        if (party && keyParty && party === keyParty) {
                            console.log(`  -> Found with party match: ${key} = ${value}`);
                            return value;
                        }
                        // If field specifies party but key doesn't have party suffix, still try matching
                        if (party && !keyParty) {
                            // Check if the key ends with the party letter
                            if (keyNormalized.endsWith(party.toLowerCase())) {
                                console.log(`  -> Found with implicit party: ${key} = ${value}`);
                                return value;
                            }
                        }
                        // If no party specified in field, return first match
                        if (!party) {
                            console.log(`  -> Found without party: ${key} = ${value}`);
                            return value;
                        }
                    }
                }
                
                // If we have a category match but no exact party match, try without party requirement
                if (party) {
                    for (const [key, value] of Object.entries(filledData)) {
                        const keyNormalized = removeVietnameseDiacritics(key).replace(/_/g, '');
                        const keyBase = keyNormalized.replace(/ben[ab]|[ab]$/gi, '');
                        
                        const keyMatchesCategory = aliases[matchedCategory].some(a => 
                            keyBase.includes(a) || a.includes(keyBase)
                        );
                        
                        if (keyMatchesCategory && key.toLowerCase().includes(party.toLowerCase())) {
                            console.log(`  -> Found with party in key: ${key} = ${value}`);
                            return value;
                        }
                    }
                }
            }
            
            console.log(`  -> No match found for: ${field}`);
            return null;
        }

        // Display contract content with sample data (for preview)
        function displayWithSampleData(content) {
            // Replace placeholder spans with their sample data
            return content.replace(
                /<span[^>]*class="[^"]*placeholder-inline[^"]*"[^>]*data-sample="([^"]*)"[^>]*>[\s\S]*?<\/span>/gi,
                (match, sampleData) => {
                    // Return the sample data, or the original if no sample
                    return sampleData || match;
                }
            );
        }
        
        // Display contract content with filled data or placeholder name for missing fields
        function displayWithFilledDataOrPlaceholder(content) {
            // Replace placeholder spans with filled data or [field_name] for missing
            // Use a more flexible regex that extracts attributes in any order
            return content.replace(
                /<span[^>]*class="[^"]*placeholder-inline[^"]*"[^>]*>[\s\S]*?<\/span>/gi,
                (match) => {
                    // Extract attributes from the match
                    const fieldMatch = match.match(/data-field="([^"]*)"/i);
                    const labelMatch = match.match(/data-label="([^"]*)"/i);
                    const sampleMatch = match.match(/data-sample="([^"]*)"/i);
                    
                    const field = fieldMatch ? fieldMatch[1] : '';
                    const label = labelMatch ? labelMatch[1] : field;
                    
                    if (!field) return match;
                    
                    // Check AI mapped data first, then fallback to getValueForField
                    let value = aiMappedData[field];
                    if (!value) {
                        value = getValueForField(field);
                    }
                    
                    if (value) {
                        // Has value - display it normally
                        return `<span class="filled-value">${escapeHtml(value)}</span>`;
                    } else {
                        // Missing - show placeholder name with highlight
                        return `<span class="missing-placeholder" title="Th√¥ng tin c√≤n thi·∫øu: ${escapeHtml(label)}">[${escapeHtml(field)}]</span>`;
                    }
                }
            );
        }
        
        // Update preview while filling form
        function updatePreviewWhileFilling() {
            if (!selectedContract) return;
            
            let content = selectedContract.modified_content || selectedContract.template || '';
            content = displayWithFilledDataOrPlaceholder(content);
            document.getElementById('contractPreviewWhileFilling').innerHTML = content;
        }

        // Open full preview modal
        function openFullPreviewModal() {
            if (!selectedContract) return;
            
            let content = selectedContract.modified_content || selectedContract.template || '';
            content = displayWithFilledDataOrPlaceholder(content);
            document.getElementById('contractPreviewModalContent').innerHTML = content;
            
            const modal = new bootstrap.Modal(document.getElementById('fullPreviewModal'));
            modal.show();
        }

        function clearChat() {
            if (confirm('X√≥a to√†n b·ªô l·ªãch s·ª≠ chat?')) {
                document.getElementById('chatContainer').innerHTML = '';
                chatHistory = [];
                selectedContract = null;
                previewingContract = null;
                missingFields = [];
                selectedTransactionType = '';
                selectedTransactionText = '';
                document.getElementById('transactionType').value = '';
                
                hideAllSections();
                document.getElementById('defaultState').style.display = 'block';
                
                showDefaultWelcome();
            }
        }

        // ========== UTILITY FUNCTIONS ==========
        
        // Remove Vietnamese diacritics (accents) from text
        function removeVietnameseDiacritics(str) {
            if (!str) return '';
            return str
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/ƒë/g, 'd')
                .replace(/ƒê/g, 'D')
                .toLowerCase();
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            return date.toLocaleDateString('vi-VN');
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function downloadContract() {
            if (!selectedContract) return;
            
            const content = document.getElementById('contractFinalPreview').innerHTML;
            
            // Create HTML document
            const html = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <title>${selectedContract.name}</title>
                    <style>
                        body { font-family: 'Times New Roman', serif; font-size: 14pt; line-height: 1.5; margin: 40px; }
                        .placeholder-inline { background: none; color: inherit; padding: 0; }
                    </style>
                </head>
                <body>${content}</body>
                </html>
            `;
            
            const blob = new Blob([html], { type: 'application/msword' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `${selectedContract.name}.doc`;
            link.click();
            
            URL.revokeObjectURL(url);
        }

        function printContract() {
            const content = document.getElementById('contractFinalPreview').innerHTML;
            
            const printWindow = window.open('', '', 'height=800,width=600');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${selectedContract?.name || 'H·ª£p ƒë·ªìng'}</title>
                    <style>
                        body { font-family: 'Times New Roman', serif; font-size: 14pt; line-height: 1.5; margin: 40px; }
                        .placeholder-inline { background: none; color: inherit; padding: 0; }
                    </style>
                </head>
                <body>${content}</body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }
    </script>
</body>
</html>
